/*
Сэндвич с мороженым — это строка, образованная двумя одинаковыми концами и разной серединой.
 Например:

AABBBAA
3&&3
yyyyymmmmmmmmyyyyy
hhhhhhhhmhhhhhhhh

Обратите внимание, что левый и правый концы сэндвича идентичны как по длине, так и 
по повторяющимся символам. Середину составляет третий (отличный от первых двух) набор 
символов.

Следующее не является сэндвичем с мороженным:

BBBBB // вы не можете иметь только мороженное (без сэндвича)
AAACCCAA // вы не можете иметь неравные по длине окончания в сэндвиче
AACDCAA // вы не можете иметь начинку из разных символов
A // ваш сэндвич не может быть менее трех символов

Напишите программу, которая возвращает true, если строка, введенная пользователем, 
является сэндвичем с мороженым, и false — в противном случае.
*/

#include <iostream>
#include <string>

// В этой функции запрашиваем строку как минимум с 3 символами.
std::string getSandwich()
{
    std::string str;
    do
    {
        std::cout << "Enter a string with at least 3 simbols\n";
        std::cin >> str;
    } while (str.length() < 3); // Повторяем цикл, пока не будет введено минимум 3 символа
    
    return str;
}

// В этой функции будем проверять, является ли переданная строка сэндвичем с мороженным. 
bool isIcecreamSandwich(std::string str)
{
    int sandwichLength = str.length();  // Запоминаем какова длина строки.
    int filling = 0;    // Изначально 0 "начинки".
    bool isIcecreamSandwich = true; // Изначально считаем, что у нас все впорядке.

    // Как провожу проверку. Я считаю сначала количество переходов слоев "начинки". В сэндвиче
    // с мороженным у нас может быть только 2 различных символа. Я считаю количество переходов
    // от начинке к начинке. К примеру в строке "AAFAA" 2 смены. От "AF" это первая смена,
    // от "FA" это вторая смена. Такое считается как сэндвич с мороженным. Если у нас 
    // "AAAFFFF" у нас происходит только одна смена, соответсвенно такое нам не подходит.
    // Ну и если у нас "AAFCFAFG" у нас происходит много смен и такое нам тоже не нужно.
    // И вместе с этим проверяется от начала и от конца идущие символы. Если происходит хоть
    // одно отличие, то тут же заканчиваем и говорим, что нет тут никакого сэндвича.
    for (int i = 0; i < sandwichLength - 1; i++)
    {
        if(str[i] != str[i + 1]) //Если два символа отличаются друг от друга
        {
            filling++; // То увеличиваем кол-во переходов от начинки к начинке.
            if(filling > 2) // Если кол-во переходов больше 2, то
            {
                isIcecreamSandwich = false; // нам такое не нужно.
                break;
            }
        }
        if(str[i] != str[sandwichLength - i - 1])   // Если символы отличаются друг от друга
                                                    // от начала и от конца, то 
        {
            isIcecreamSandwich = false; // такое нам тоже не нужно.
            break;
        }
    }

    if(filling < 2) // Ну и соответсвенно, если у нас меньше одной смены начинки,
                    // к примеру "AAFFFF", то 
        isIcecreamSandwich = false; // нам такое тоже не нужно.

    return isIcecreamSandwich;
}

int main()
{
    std::string sandwich = getSandwich();

    switch (isIcecreamSandwich(sandwich))
    {
        case 0: std::cout << "Your string isn't a sandwich"; break;
        case 1: std::cout << "Your string is a sandwich"; break;
    }

    return 0;
}