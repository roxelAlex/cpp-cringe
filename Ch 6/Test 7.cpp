/*
Это задание уже немного сложнее.
Еще одним простым методом сортировки элементов является «сортировка пузырьком»
(или "пузырьковая сортировка"). Суть заключается в сравнении пары значений,
которые находятся рядом, и, если удовлетворены заданные критерии, значения из
этой пары меняются местами. И таким образом элементы «скачут пузырьком» до
конца массива. Хотя есть несколько способов оптимизировать сортировку
пузырьком, в этом задании мы будем придерживаться неоптимизированной версии,
так как она проще.
При неоптимизированной версии сортировки пузырьком выполняются следующие шаги
для сортировки массива от наименьшего до наибольшего значения:
 Сравнивается элемент массива под индексом 0 с элементом массива под
индексом 1. Если элемент под индексом 0 больше элемента под индексом 1,
то значения меняются местами.
 Затем мы перемещаемся к следующей паре значений: элемент под индексом 1 и
элемент под индексом 2 и так до тех пор, пока не достигнем конца массива.
 Повторяем шаг №1 и шаг №2 до тех пор, пока весь массив не будет отсортирован.
Напишите программу, которая отсортирует следующий массив сортировкой
пузырьком в соответствии с правилами, указанными выше:
    const int length(9); 
    int array[length] = { 7, 5, 6, 4, 9, 8, 2, 1, 3 };
В конце программы выведите отсортированные элементы массива.
*/

#include <iostream>
#include <algorithm>

int main()
{
    const int length(9);
    int array[length] = { 7, 5, 6, 4, 9, 8, 2, 1, 3 };

    // Проходимся по всей длине массива.
    for (int iteration = 0; iteration < length - 1; ++iteration)
    {
        // Меняем элементы массива местами, если первый больше второго.
        for (int currentIndex = 0; currentIndex < length - 1; ++currentIndex)
        {
            if (array[currentIndex] > array[currentIndex + 1])
                std::swap(array[currentIndex], array[currentIndex + 1]);
        }
    }

    for (int index = 0; index < length; ++index)
    {
        std::cout << array[index] << " ";
    }
    return 0;
}